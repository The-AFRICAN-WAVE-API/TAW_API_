// services/rssService.js
import {throttleRequests} from '../utils/throttle.js';
import feedUrls from '../feedUrls.js';
import {categorizeArticleRuleBased, analyzeSentiment, analyzeEntities, categorizeArticleML} from'../utils/analysis.js';
import {getUniqueKey} from '../utils/helpers.js';
import admin from '../configuration/firebase.js';
import {detectLanguage} from '../utils/languages/languageDetection.js';
import striptags from 'striptags';
const db = admin.firestore();

/**
 * Attempts to extract an image URL from an RSS item using multiple strategies.
 * @param {Object} item - RSS item
 * @return {string|null} - Image URL or null
 */
function extractImageUrl(item) {
  if (item.enclosure && item.enclosure.url) return item.enclosure.url;
  const imgMatch = item.content?.match(/<img[^>]+src="([^">]+)"/i);
  if (imgMatch && imgMatch[1]) return imgMatch[1];
  return null;
}

/**
 * Strips HTML tags and gets the best available content for analysis.
 * @param {Object} item - RSS feed item
 * @return {string} - Cleaned text content
 */
function extractCleanContent(item) {
  const raw =
    item['content:encoded'] || item.content || item.description || item.contentSnippet || '';
  return striptags(raw);
}
/**
 * Processes RSS feeds: fetches feeds, processes items, and stores them in Firestore.
 * Duplicate checking is handled by using a unique key (generated by getUniqueKey) as the document ID.
 * Firestore's upsert behavior (using {merge: true}) ensures that if a document already exists,
 * it will be updated rather than creating a duplicate.
 * @return {Promise<Object>} Result message and count.
 */
export async function fetchAndStoreRssFeeds() {
  const feeds = await throttleRequests(feedUrls);
  let batch = db.batch();
  const MAX_BATCH_SIZE = 500;
  let operationCount = 0;

  for (const feed of feeds) {
    if (!feed || !feed.items) continue;
    const processedItems = await Promise.all(
      feed.items.map(async (item) => {
        const contentForAnalysis = extractCleanContent(item);
        const category = categorizeArticleRuleBased(contentForAnalysis);

        const categoryML = categorizeArticleML(contentForAnalysis);

        const sentiment = analyzeSentiment(contentForAnalysis);
        let entities = {};
        try {
          entities = await analyzeEntities(contentForAnalysis);
        } catch (e) {
          console.error('Entity analysis failed for article:', item.title, e);
        }
        let geoLocation = null;
        if (item['geo:lat'] && item['geo:long']) {
          geoLocation = { lat: parseFloat(item['geo:lat']), lng: parseFloat(item['geo:long']) };
        } else if (entities.places && entities.places.length > 0) {
          geoLocation = entities.places[0];
        }

        const imageUrl = extractImageUrl(item); 
        // <--updated image logic here
        // Language detection and translation (if needed)
        const detectedLanguage = detectLanguage(contentForAnalysis);
        // Duplicate checking: using the unique key as the Firestore doc ID prevents duplicate entries.
        const uniqueKey = getUniqueKey(item.title, item.link);
        return {
          uniqueKey,
          data: {
            title: item.title,
            link: item.link,
            pubDate: item.pubDate || null,
            source: feed.title,
            category,
            categoryML,
            sentiment,
            entities,
            location: geoLocation,
            description: contentForAnalysis,
            language: detectedLanguage,
            imageUrl,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          },
        };
      }),
    );
    for (const {uniqueKey, data} of processedItems) {
      const collectionRef = db.collection('rss_articles').doc(data.category).collection('articles');
      const docRef = collectionRef.doc(uniqueKey);

      // Upsert operation: If a document with uniqueKey already exists, this will update it (preventing duplicates)
      batch.set(docRef, data, {merge: true});
      operationCount++;
      if (operationCount >= MAX_BATCH_SIZE) {
        await batch.commit();
        console.log('Committed a batch of RSS articles, count:', operationCount);
        batch = db.batch();
        operationCount = 0;
      }
    }
  }
  if (operationCount > 0) {
    await batch.commit();
    console.log('Final batch commit executed for RSS articles, remaining count:', operationCount);
  }
  return {message: 'RSS feeds stored successfully', count: feeds.length};
}