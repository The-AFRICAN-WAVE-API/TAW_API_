// services/rssService.js
import { throttleRequests } from '../utils/throttle.js';
import feedUrls from '../feedUrls.js';
 main
import { analyzeSentiment, analyzeEntities, categorizeArticleML } from '../utils/analysis.js';
import { getUniqueKey } from '../utils/helpers.js';
import { db, admin } from '../configuration/firebase.js';
import { detectLanguage } from '../utils/languages/languageDetection.js';

import {categorizeArticleRuleBased, analyzeSentiment, analyzeEntities, categorizeArticleML} from'../utils/analysis.js';
import {getUniqueKey} from '../utils/helpers.js';
import admin from '../configuration/firebase.js';
import {detectLanguage} from '../utils/languages/languageDetection.js';
import striptags from 'striptags';
import pusher from '../pusher.js';
import {extract} from '@extractus/article-extractor';
const db = admin.firestore();
main

/**
 * Attempts to extract an image URL from article extractor
 * fallback to RSS item if needed.
 * @param {Object} extracted - Extracted article
 * @param {Object} item - RSS item
 * @return {string|null} - Image URL or null
 */
function extractImageUrl(extracted, item) {
  if (extracted?.image) return extracted.image;
  if (item.enclosure?.url) return item.enclosure.url;
  const imgMatch = item.content?.match(/<img[^>]+src="([^"]+)"/i);
  return imgMatch?.[1] || null;
}

// list of breaking news keywords
const breakingNewsKeywords = [
  'breaking', 'alert', 'news', 'update', 'developing',
  'just in', 'exclusive', 'urgent', 'evacuate', 'incident'
];

// Function to push breaking news alert via Pusher
async function pushBreakingNewsAlert(title, content) {
  const alert = { title, content, time: new Date().toISOString() };
  pusher.trigger('news-channel', 'breaking-news', alert);
  await db.collection('breaking_news').add({
    ...alert,
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
  });
}
function extractCleanContent(item) {
  const raw =
    item['content:encoded'] || item.content || item.description || item.contentSnippet || '';
  return striptags(raw);
}
/**
 * Processes RSS feeds: fetches feeds, processes items, and stores them in Firestore.
 * Duplicate checking is handled by using a unique key (generated by getUniqueKey) as the document ID.
 * Firestore's upsert behavior (using {merge: true}) ensures that if a document already exists,
 * it will be updated rather than creating a duplicate.
 * @return {Promise<Object>} Result message and count.
 */
export async function fetchAndStoreRssFeeds() {
  const feeds = await throttleRequests(feedUrls);
  let batch = db.batch();
  const MAX_BATCH_SIZE = 500;
  let operationCount = 0;

  for (const feed of feeds) {
    if (!feed || !feed.items) continue;
    const processedItems = await Promise.all(
      feed.items.map(async (item) => {
        const contentForAnalysis = extractCleanContent(item);
        const category = categorizeArticleRuleBased(contentForAnalysis);

        const categoryML = categorizeArticleML(contentForAnalysis);

        const sentiment = analyzeSentiment(contentForAnalysis);
        let entities = {};
        try {
          entities = await analyzeEntities(contentForAnalysis);
        } catch (e) {
          console.error('Entity analysis failed for article:', item.title, e);
        }
        let geoLocation = null;
        if (item['geo:lat'] && item['geo:long']) {
          geoLocation = { lat: parseFloat(item['geo:lat']), lng: parseFloat(item['geo:long']) };
        } else if (entities.places?.length) {
          geoLocation = entities.places[0];
        }

        let extracted;
        try {
          extracted = await extract(item.link);
        } catch (err) {
          console.warn(`Extraction failed for ${item.link}:`, err.message);
        }
        const imageUrl = extractImageUrl(extracted, item);
        // <--updated image logic here
        // Language detection and translation (if needed)
        const detectedLanguage = detectLanguage(contentForAnalysis);
        // Duplicate checking: using the unique key as the Firestore doc ID prevents duplicate entries.
        const uniqueKey = getUniqueKey(item.title, item.link);

        const contentText = (item.title + ' ' + (item.content || '') + ' ' + (item.description || '')).toLowerCase();
        const isBreaking = breakingNewsKeywords.some(keyword => contentText.includes(keyword));
        if (isBreaking) {
          await pushBreakingNewsAlert(item.title, item.description || item.content || '');
        }
        return {
          uniqueKey,
          data: {
            title: item.title,
            link: item.link,
            pubDate: item.pubDate || null,
            source: feed.title,
            category,
            categoryML,
            sentiment,
            entities,
            location: geoLocation,
            description: contentForAnalysis,
            language: detectedLanguage,
            imageUrl,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          },
        };
      }),
    );
    for (const { uniqueKey, data } of processedItems) {
      const collectionRef = db.collection('rss_articles').doc(data.category).collection('articles');
      const docRef = collectionRef.doc(uniqueKey);

      // Upsert operation: If a document with uniqueKey already exists, this will update it (preventing duplicates)
      batch.set(docRef, data, { merge: true });
      operationCount++;
      if (operationCount >= MAX_BATCH_SIZE) {
        await batch.commit();
        console.log('Committed a batch of RSS articles, count:', operationCount);
        batch = db.batch();
        operationCount = 0;
      }
    }
  }
  if (operationCount > 0) {
    await batch.commit();
    console.log('Final batch commit executed for RSS articles, remaining count:', operationCount);
  }
  return { message: 'RSS feeds stored successfully', count: feeds.length };
}