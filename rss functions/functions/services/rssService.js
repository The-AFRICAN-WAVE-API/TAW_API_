// services/rssService.js
import { throttleRequests } from '../utils/throttle.js';
import feedUrls from '../feedUrls.js';
import { analyzeSentiment, analyzeEntities, categorizeArticleML } from '../utils/analysis.js';
import { getUniqueKey } from '../utils/helpers.js';
import { db, admin } from '../configuration/firebase.js';
import { detectLanguage } from '../utils/languages/languageDetection.js';

/**
 * Attempts to extract an image URL from an RSS item using multiple strategies.
 * @param {Object} item - RSS item
 * @return {string|null} - Image URL or null
 */
function extractImageUrl(item) {
  if (item.enclosure && item.enclosure.url) return item.enclosure.url;
  const imgMatch = item.content?.match(/<img[^>]+src="([^">]+)"/i);
  if (imgMatch && imgMatch[1]) return imgMatch[1];
  return null;
}

/**
 * Processes RSS feeds: fetches feeds, processes items, and stores them in Firestore.
 * Duplicate checking is handled by using a unique key (generated by getUniqueKey) as the document ID.
 * Firestore's upsert behavior (using {merge: true}) ensures that if a document already exists,
 * it will be updated rather than creating a duplicate.
 * @return {Promise<Object>} Result message and count.
 */
export async function fetchAndStoreRssFeeds() {
  const feeds = await throttleRequests(feedUrls);
  let batch = db.batch();
  const MAX_BATCH_SIZE = 500;
  let operationCount = 0;

  for (const feed of feeds) {
    if (!feed || !feed.items) continue;
    const processedItems = await Promise.all(
      feed.items.map(async (item) => {
        const contentForAnalysis = item['content:encoded'] || item.content || item.description || item.contentSnippet || '';
        const categoryML = categorizeArticleML(contentForAnalysis);

        const sentiment = analyzeSentiment(contentForAnalysis);
        let entities = {};
        try {
          entities = await analyzeEntities(contentForAnalysis);
        } catch (e) {
          console.error('Entity analysis failed for article:', item.title, e);
        }
        let geoLocation = null;
        if (item['geo:lat'] && item['geo:long']) {
          geoLocation = { lat: parseFloat(item['geo:lat']), lng: parseFloat(item['geo:long']) };
        } else if (entities.places && entities.places.length > 0) {
          geoLocation = entities.places[0];
        }

        const imageUrl = extractImageUrl(item);  // <-- updated image logic here
        // Language detection and translation (if needed)
        const detectedLanguage = detectLanguage(contentForAnalysis);
        // Duplicate checking: using the unique key as the Firestore doc ID prevents duplicate entries.
        const uniqueKey = getUniqueKey(item.title, item.link);
        return {
          uniqueKey,
          data: {
            title: item.title,
            link: item.link,
            pubDate: item.pubDate || null,
            source: feed.title,
            categoryML,
            sentiment,
            entities,
            location: geoLocation,
            description: contentForAnalysis,
            language: detectedLanguage,
            imageUrl,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          },
        };
      }),
    );
    for (const { uniqueKey, data } of processedItems) {
      const collectionRef = db.collection('rss_articles').doc(data.category).collection('articles');
      const docRef = collectionRef.doc(uniqueKey);

      // Upsert operation: If a document with uniqueKey already exists, this will update it (preventing duplicates)
      batch.set(docRef, data, { merge: true });
      operationCount++;
      if (operationCount >= MAX_BATCH_SIZE) {
        await batch.commit();
        console.log('Committed a batch of RSS articles, count:', operationCount);
        batch = db.batch();
        operationCount = 0;
      }
    }
  }
  if (operationCount > 0) {
    await batch.commit();
    console.log('Final batch commit executed for RSS articles, remaining count:', operationCount);
  }
  return { message: 'RSS feeds stored successfully', count: feeds.length };
}